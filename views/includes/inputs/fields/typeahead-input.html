<script type="text/javascript" src="{{assetPath}}/javascripts/app/accessible-autocomplete.min.js"></script>


<script type="text/javascript">
const typeahead = "{{typeahead_array}}"
const typeaheadArray = typeahead.split(",")
accessibleAutocomplete({
  element: document.querySelector('#my-autocomplete-container'),
  id: 'typeahead_input', // To match it to the existing <label>.
  source: typeaheadArray,
  name: 'typeahead_input',
  defaultValue:'{{typeahead_value}}'
})

  // Mimic nunjucks error generation
  window.onload = function () {
    // Set up observor to correct css classname when accessible-autocomplete rewrites the input field.
    const typeaheadNode = document.getElementById("typeahead_input");
    const typeaheadError = "{{errors.typeahead_input.text}}";
    var callback;
    var inputClass;

    if (typeaheadError) {
      document.getElementById("my-autocomplete-container").className = "govuk-form-group govuk-form-group--error";
      const errorHtml = '<p id="nationality-error" class="govuk-error-message"> <span class="govuk-visually-hidden">Error:</span> ' + typeaheadError + '</p>'
      const element = document.getElementById("typeahead-hint");
      element.insertAdjacentHTML("afterend", errorHtml);
      inputClass = "govuk-input govuk-input--width-20 govuk-input--error";
      typeaheadNode.className = inputClass;
    }
    else {
      inputClass = "govuk-input govuk-input--width-20";
      typeaheadNode.className = inputClass;
    }

    callback = (mutationList, observer) => {
      for (const mutation of mutationList) {
        if (mutation.type === "attributes") {
          if (typeaheadNode.className !== inputClass) {
            typeaheadNode.className = inputClass;
          }
        }
      }
    };
    const config = { attributes: true, childList: false, subtree: false };
    const observer = new MutationObserver(callback);
    observer.observe(typeaheadNode, config);
  }


</script>